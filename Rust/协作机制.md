Rust 中的"协作"概念与传统面向对象语言有所不同，因为 Rust 没有传统意义上的"类"。不过，Rust 提供了多种强大的机制来实现类型之间的协作：

## 主要协作机制

**1. Trait 系统**

```rust
trait Draw {
    fn draw(&self);
}

struct Circle { radius: f64 }
struct Rectangle { width: f64, height: f64 }

impl Draw for Circle {
    fn draw(&self) { println!("Drawing circle with radius {}", self.radius); }
}

impl Draw for Rectangle {
    fn draw(&self) { println!("Drawing rectangle {}x{}", self.width, self.height); }
}

// 多态使用
fn render_shapes(shapes: Vec<Box<dyn Draw>>) {
    for shape in shapes {
        shape.draw();
    }
}
```

**2. 组合优于继承**

```rust
struct Engine { power: u32 }
struct Transmission { gears: u8 }

struct Car {
    engine: Engine,
    transmission: Transmission,
}

impl Car {
    fn start(&self) {
        println!("Starting car with {}HP engine", self.engine.power);
    }
}
```

**3. 枚举和模式匹配**

```rust
enum Message {
    Text(String),
    Move { x: i32, y: i32 },
    Quit,
}

struct Handler;

impl Handler {
    fn process(&self, msg: Message) {
        match msg {
            Message::Text(s) => println!("Text: {}", s),
            Message::Move { x, y } => println!("Move to ({}, {})", x, y),
            Message::Quit => println!("Quitting"),
        }
    }
}
```

## 常用设计模式在 Rust 中的实现

**策略模式**

```rust
trait SortStrategy {
    fn sort(&self, data: &mut Vec<i32>);
}

struct BubbleSort;
struct QuickSort;

impl SortStrategy for BubbleSort {
    fn sort(&self, data: &mut Vec<i32>) {
        // bubble sort implementation
    }
}

struct Sorter {
    strategy: Box<dyn SortStrategy>,
}
```

**建造者模式**

```rust
struct Config {
    host: String,
    port: u16,
    timeout: u64,
}

impl Config {
    fn builder() -> ConfigBuilder {
        ConfigBuilder::default()
    }
}

#[derive(Default)]
struct ConfigBuilder {
    host: Option<String>,
    port: Option<u16>,
    timeout: Option<u64>,
}

impl ConfigBuilder {
    fn host(mut self, host: String) -> Self {
        self.host = Some(host);
        self
    }
    
    fn port(mut self, port: u16) -> Self {
        self.port = Some(port);
        self
    }
    
    fn build(self) -> Result<Config, String> {
        Ok(Config {
            host: self.host.ok_or("Host is required")?,
            port: self.port.unwrap_or(8080),
            timeout: self.timeout.unwrap_or(30),
        })
    }
}
```

## Rust 特有的协作特性

**所有权和借用**

```rust
struct Database {
    connection: String,
}

struct UserService<'a> {
    db: &'a Database,  // 借用引用
}

impl<'a> UserService<'a> {
    fn new(db: &'a Database) -> Self {
        UserService { db }
    }
    
    fn get_user(&self, id: u32) -> String {
        format!("User {} from {}", id, self.db.connection)
    }
}
```

**泛型和关联类型**

```rust
trait Iterator {
    type Item;
    fn next(&mut self) -> Option<Self::Item>;
}

struct Counter {
    current: usize,
    max: usize,
}

impl Iterator for Counter {
    type Item = usize;
    
    fn next(&mut self) -> Option<Self::Item> {
        if self.current < self.max {
            let current = self.current;
            self.current += 1;
            Some(current)
        } else {
            None
        }
    }
}
```

Rust 更多依靠 trait、组合、枚举和模式匹配来实现类型协作，这种方式比传统的继承更加灵活和安全，同时利用所有权系统保证内存安全。