很好，这一步已经是**“把哲学变成工程制度”**了。
下面这份 **C++ 项目「状态一致性 checklist」**，不是“最佳实践合集”，而是：

> **一份用来判断：这个 C++ 项目还能不能被长期维护、能不能在故障时保持状态可推理的清单。**

你可以把它当成 **C++ 世界里的人肉 borrow checker + STW 纪律表**。

------

# C++ 项目状态一致性 Checklist（工程级）

## ✅ 0. 总体判定（先做这 5 问）

如果下面 **任意 2 条答不上来**，项目已处于高风险区：

- 是否能画出 **核心对象的生命周期图**？
- 是否知道 **哪些线程能改哪些状态**？
- 是否能枚举 **所有“共享可变状态”**？
- 是否知道 **系统崩溃时，哪些状态一定是一致的**？
- 是否存在 **“只要不出 bug 就没问题”** 的假设？

------

## 1️⃣ 生命周期与所有权（最重要）

### ✔️ 必须满足

-  `new` / `delete` 不直接出现于业务代码
-  所有动态对象：
  -  `unique_ptr`（默认）
  -  `shared_ptr`（极少数，且有文档）
-  所有 `shared_ptr`：
  -  生命周期 > 所有使用者
  -  不形成环（或明确 weak_ptr 断环点）
-  析构函数：
  -  **不抛异常**
  -  不依赖外部状态顺序

### ❌ 高危信号

- 裸指针表达“拥有关系”
- `init()` / `destroy()` 成对调用
- 对象是否存活只能靠“约定”

------

## 2️⃣ 指针 / 引用使用规则

### ✔️ 必须满足

-  函数参数中：
  - `T*` → **必须文档说明是否 owning**
  - `T&` → 生命周期 ≤ 调用栈
-  成员变量中：
  - 禁止保存外部对象的裸指针
-  非 owning 指针：
  -  只用于同步、短期观察
  -  不跨线程、不跨 async

### ❌ 高危信号

- 成员变量里有 `T*`
- lambda 捕获裸指针并异步执行

------

## 3️⃣ 状态变更与不变量

### ✔️ 必须满足

-  构造完成后，对象立即处于 **有效状态**
-  任意 public 方法：
  -  不破坏对象不变量
-  状态修改：
  -  封装在 RAII / scope guard 中
-  不存在“半初始化对象”对外可见

### ❌ 高危信号

- `bool initialized_`
- `reset()` / `reinit()` 这种方法大量存在

------

## 4️⃣ 并发与内存模型（重灾区）

### ✔️ 必须满足

-  明确并发模型：
  -  actor / message
  -  thread pool + work queue
-  共享可变状态：
  -  每一块都对应一个 mutex / 原子策略
-  mutex：
  -  有明确保护范围文档
-  atomic：
  -  不使用 `memory_order_relaxed`（除非审计）

### ❌ 高危信号

- “这个变量一般不会被并发访问”
- 原子变量 + 非原子变量混合使用

------

## 5️⃣ 错误处理一致性

### ✔️ 必须满足

-  **只使用一种错误模型**：
  - exceptions **或**
  - `expected<T, E>`
-  构造失败：
  -  对象不存在
-  错误路径：
  -  不泄漏资源
  -  不留下部分状态

### ❌ 高危信号

- 返回值表示错误 + 仍然抛异常
- 忽略返回值继续执行

------

## 6️⃣ UB（未定义行为）围栏

### ✔️ 必须满足

-  UB 操作集中在少数文件
-  这些文件：
  -  有注释说明假设
  -  有测试覆盖
-  编译选项：
  - ASan / UBSan / TSan 定期跑
-  禁止：
  - strict-aliasing 依赖
  - 未初始化内存读

### ❌ 高危信号

- “这在 x86 上没问题”
- reinterpret_cast 到处都是

------

## 7️⃣ 模块边界与封装

### ✔️ 必须满足

-  模块对外：
  - 不暴露内部可变状态
-  跨模块：
  -  传值 / ID
  -  不传对象指针
-  全局变量：
  -  极少
  -  启动期初始化完成

### ❌ 高危信号

- `extern` 到处飞
- 全局单例隐式修改状态

------

## 8️⃣ 析构与退出路径（最容易被忽略）

### ✔️ 必须满足

-  程序退出路径：
  -  顺序可预测
-  static 对象：
  -  不依赖其他 static 的析构顺序
-  后台线程：
  -  明确 join / stop 点

### ❌ 高危信号

- 靠进程退出“自动回收”
- 析构中锁 mutex

------

## 9️⃣ 工具与流程（不是可选项）

### ✔️ 必须满足

-  CI 包含：
  - ASan
  - UBSan
  - TSan
-  clang-tidy 规则集启用
-  code review 必查：
  - 生命周期
  - 并发
  - 错误路径

------

## 🔚 最终判断标准（非常重要）

> **如果你不能在白板上画出：
> 对象 → 所有者 → 线程 → 锁 → 生命周期
> 这条链路，
> 那这个项目的状态一致性是“假设成立的”。**

------

## 给你一个“系统派”结语

> **C++ 项目不是靠“写得好”保持一致性，
> 而是靠“不让你写坏”。**

如果你愿意，下一步我可以帮你：

- 把这份 checklist **转成 code review 模板**
- 对照 Rust：每一条对应 borrow checker 的哪条规则
- 用真实事故案例逐条打勾/打叉分析

你想怎么用它？